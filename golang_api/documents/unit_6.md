# üìã ‡∏™‡∏≤‡∏£‡∏ö‡∏±‡∏ç

1. [Concurrency VS Parallelism](#concurrency-vs-parallelism)
2. [Goroutines](#goroutines)
3. [Channels](#channels)

# Concurrency VS Parallelism

## ‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡∏Ç‡πâ‡∏≠‡πÅ‡∏ï‡∏Å‡∏ï‡πà‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÅ‡∏ö‡∏ö Concurrency ‡πÅ‡∏•‡∏∞ Parallelism

### üîç ‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏ó‡∏µ‡πà‡∏û‡∏ö‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°

‡πÇ‡∏î‡∏¢‡∏õ‡∏Å‡∏ï‡∏¥‡πÅ‡∏•‡πâ‡∏ß ‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏≤‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏à‡∏∞‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ö‡∏ô CPU ‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡πÅ‡∏Ñ‡πà 1 core ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô ‡πÅ‡∏°‡πâ‡∏ß‡πà‡∏≤ CPU ‡∏à‡∏∞‡∏°‡∏µ‡∏´‡∏•‡∏≤‡∏¢ core ‡∏Å‡πá‡∏ï‡∏≤‡∏° ‡∏ã‡∏∂‡πà‡∏á‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡πÄ‡∏£‡∏≤‡πÉ‡∏ä‡πâ‡∏ó‡∏£‡∏±‡∏û‡∏¢‡∏≤‡∏Å‡∏£‡∏Ç‡∏≠‡∏á CPU ‡πÑ‡∏î‡πâ‡πÑ‡∏°‡πà‡πÄ‡∏ï‡πá‡∏°‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û

```
CPU ‡∏°‡∏µ 4 cores ‡πÅ‡∏ï‡πà‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡πÉ‡∏ä‡πâ‡πÅ‡∏Ñ‡πà 1 core
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  ‚úì  ‚îÇ  -  ‚îÇ  -  ‚îÇ  -  ‚îÇ ‚Üê ‡πÄ‡∏™‡∏µ‡∏¢‡∏î‡∏≤‡∏¢‡∏ó‡∏£‡∏±‡∏û‡∏¢‡∏≤‡∏Å‡∏£!
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### üí° ‡∏´‡∏•‡∏±‡∏Å‡∏Å‡∏≤‡∏£‡∏Ç‡∏≠‡∏á Concurrency

**Concurrency** ‡∏Ñ‡∏∑‡∏≠‡∏Å‡∏≤‡∏£‡πÅ‡∏ö‡πà‡∏á‡∏á‡∏≤‡∏ô‡πÉ‡∏´‡∏ç‡πà‡∏≠‡∏≠‡∏Å‡πÄ‡∏õ‡πá‡∏ô‡∏á‡∏≤‡∏ô‡πÄ‡∏•‡πá‡∏Å‡πÜ ‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÅ‡∏¢‡∏Å‡∏à‡∏≤‡∏Å‡∏Å‡∏±‡∏ô‡πÑ‡∏î‡πâ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏≠‡∏¥‡∏™‡∏£‡∏∞

**‡∏Ñ‡∏∏‡∏ì‡∏™‡∏°‡∏ö‡∏±‡∏ï‡∏¥‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç:**

- ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏á‡∏≤‡∏ô‡∏¢‡πà‡∏≠‡∏¢‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏≠‡∏¥‡∏™‡∏£‡∏∞‡∏à‡∏≤‡∏Å‡∏Å‡∏±‡∏ô
- ‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÑ‡∏°‡πà‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç (‡∏ó‡∏≥‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á‡πÑ‡∏î‡πâ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Å‡∏±‡∏ô)
- ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÅ‡∏ö‡∏ö interleaving ‡∏ö‡∏ô CPU core ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß

```
‡∏á‡∏≤‡∏ô‡πÄ‡∏î‡∏¥‡∏°: [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà]

‡πÅ‡∏ö‡πà‡∏á‡πÄ‡∏õ‡πá‡∏ô Concurrent Tasks:
Task 1: [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà]
Task 2: [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà]
Task 3: [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà]

‚úÖ T1 ‚Üí T2 ‚Üí T3 = ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô
‚úÖ T2 ‚Üí T1 ‚Üí T3 = ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô
```

### ‚ö° ‡∏´‡∏•‡∏±‡∏Å‡∏Å‡∏≤‡∏£‡∏Ç‡∏≠‡∏á Parallelism

**Parallelism** ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡∏∂‡πâ‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏≤‡∏°‡∏µ CPU ‡∏´‡∏•‡∏≤‡∏¢ core ‡πÅ‡∏•‡∏∞‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏≠‡∏≤‡∏á‡∏≤‡∏ô‡∏¢‡πà‡∏≠‡∏¢‡πÑ‡∏õ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô‡πÑ‡∏î‡πâ‡∏à‡∏£‡∏¥‡∏á‡πÜ

```
CPU ‡∏°‡∏µ 4 cores - ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ T1  ‚îÇ T2  ‚îÇ T3  ‚îÇ T4  ‚îÇ ‚Üê ‡πÉ‡∏ä‡πâ‡∏ó‡∏£‡∏±‡∏û‡∏¢‡∏≤‡∏Å‡∏£‡πÄ‡∏ï‡πá‡∏°‡∏ó‡∏µ‡πà!
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### üéØ ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏±‡∏°‡∏û‡∏±‡∏ô‡∏ò‡πå‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á Concurrency ‡πÅ‡∏•‡∏∞ Parallelism

> **‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç:** Parallelism ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡∏∂‡πâ‡∏ô‡πÑ‡∏î‡πâ‡∏Å‡πá‡∏ï‡πà‡∏≠‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ Concurrency ‡πÄ‡∏™‡∏µ‡∏¢‡∏Å‡πà‡∏≠‡∏ô

- **Concurrency without Parallelism:** ‡∏á‡∏≤‡∏ô‡∏¢‡πà‡∏≠‡∏¢‡∏´‡∏•‡∏≤‡∏¢‡∏ï‡∏±‡∏ß‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏™‡∏•‡∏±‡∏ö‡∏Å‡∏±‡∏ô‡∏ö‡∏ô CPU core ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß
- **Concurrency with Parallelism:** ‡∏á‡∏≤‡∏ô‡∏¢‡πà‡∏≠‡∏¢‡∏´‡∏•‡∏≤‡∏¢‡∏ï‡∏±‡∏ß‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô‡∏ö‡∏ô CPU ‡∏´‡∏•‡∏≤‡∏¢ core

---

# Goroutines

## ‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏£‡∏π‡πâ‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÅ‡∏ö‡∏ö Concurrency ‡∏î‡πâ‡∏ß‡∏¢ Goroutines ‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô sync.WaitGroup

### üöÄ Goroutines ‡∏Ñ‡∏∑‡∏≠‡∏≠‡∏∞‡πÑ‡∏£?

Goroutines ‡πÄ‡∏õ‡πá‡∏ô lightweight threads ‡∏Ç‡∏≠‡∏á Go ‡∏ó‡∏µ‡πà‡∏ä‡πà‡∏ß‡∏¢‡πÉ‡∏´‡πâ‡πÄ‡∏£‡∏≤‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÅ‡∏ö‡∏ö concurrent ‡πÑ‡∏î‡πâ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏á‡πà‡∏≤‡∏¢‡∏î‡∏≤‡∏¢

### üìù ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô - ‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏ó‡∏µ‡πà‡∏û‡∏ö

```go
package main

import (
  "fmt"
  "time"
)

func printAndSleep(number int) {
  time.Sleep(1 * time.Second) // ‡∏´‡∏•‡∏±‡∏ö 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡∏Å‡πà‡∏≠‡∏ô
  fmt.Println(number)
}

func main() {
  for i := 1; i <= 10; i++ {
    printAndSleep(i) // Sequential execution
  }
}
```

**‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå:** ‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤‡∏£‡∏ß‡∏° 10 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ (1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ √ó 10 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á)

```
‡∏´‡∏•‡∏±‡∏ö 1 ‡∏ß‡∏¥ ‚Üí print: 1
‡∏´‡∏•‡∏±‡∏ö 1 ‡∏ß‡∏¥ ‚Üí print: 2
‡∏´‡∏•‡∏±‡∏ö 1 ‡∏ß‡∏¥ ‚Üí print: 3
...
‡∏£‡∏ß‡∏°: 10 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ üò¥
```

### ‚ö° ‡πÅ‡∏Å‡πâ‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏î‡πâ‡∏ß‡∏¢ Goroutines

```go
package main

import (
  "fmt"
  "sync"
  "time"
)

func printAndSleep(number int, wg *sync.WaitGroup) {
  defer wg.Done() // ‚ú® ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á: ‡πÉ‡∏ä‡πâ defer ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢

  time.Sleep(1 * time.Second)
  fmt.Println(number)
}

func main() {
  var wg sync.WaitGroup

  for i := 1; i <= 10; i++ {
    wg.Add(1) // ‡∏ö‡∏≠‡∏Å‡∏ß‡πà‡∏≤‡∏à‡∏∞‡∏°‡∏µ goroutine ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏∂‡πâ‡∏ô 1 ‡∏ï‡∏±‡∏ß
    go printAndSleep(i, &wg) // üöÄ ‡∏™‡∏£‡πâ‡∏≤‡∏á goroutine
  }

  wg.Wait() // ‡∏£‡∏≠‡πÉ‡∏´‡πâ goroutines ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÄ‡∏™‡∏£‡πá‡∏à
  fmt.Println("All goroutines completed!")
}
```

**‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå:** ‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏û‡∏µ‡∏¢‡∏á ~1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ (‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô!)

```
‡∏ó‡∏±‡πâ‡∏á 10 ‡∏á‡∏≤‡∏ô‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô ‚Üí ‡πÄ‡∏™‡∏£‡πá‡∏à‡πÉ‡∏ô ~1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ üöÄ
Output: 3, 1, 7, 2, 9, 5, 8, 4, 10, 6 (‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏≠‡∏≤‡∏à‡πÑ‡∏°‡πà‡πÄ‡∏£‡∏µ‡∏¢‡∏á)
```

### üîß ‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏à‡∏≤‡∏Å‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏î‡∏¥‡∏°

**‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á:**

1. **‡πÉ‡∏ä‡πâ `defer wg.Done()`** ‡πÅ‡∏ó‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡πâ‡∏≤‡∏¢ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢
2. **‡∏™‡πà‡∏á WaitGroup ‡πÄ‡∏õ‡πá‡∏ô pointer** ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏î‡∏µ‡∏Ç‡∏∂‡πâ‡∏ô
3. **‡πÄ‡∏û‡∏¥‡πà‡∏° error handling** ‡πÉ‡∏ô‡∏Å‡∏£‡∏ì‡∏µ‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô

### üìä ‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô

| ‡πÅ‡∏ö‡∏ö Sequential     | ‡πÅ‡∏ö‡∏ö Concurrent (Goroutines)   |
| ------------------ | ----------------------------- |
| ‚è±Ô∏è 10 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ       | ‚è±Ô∏è ~1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ                  |
| üîÑ ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ó‡∏µ‡∏•‡∏∞‡∏á‡∏≤‡∏ô    | üöÄ ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô 10 ‡∏á‡∏≤‡∏ô       |
| üíæ ‡πÉ‡∏ä‡πâ memory ‡∏ô‡πâ‡∏≠‡∏¢ | üíæ ‡πÉ‡∏ä‡πâ memory ‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢ |

### ‚ö†Ô∏è ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏£‡∏£‡∏∞‡∏ß‡∏±‡∏á

1. **Race Condition:** ‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô
2. **Memory Usage:** Goroutines ‡πÉ‡∏ä‡πâ memory ‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì 2KB ‡∏ï‡πà‡∏≠‡∏ï‡∏±‡∏ß
3. **Goroutine Leaks:** ‡∏≠‡∏¢‡πà‡∏≤‡∏•‡∏∑‡∏°‡πÉ‡∏ä‡πâ WaitGroup ‡∏´‡∏£‡∏∑‡∏≠ Context ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏° lifecycle

---

# Channels

## ‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡∏´‡∏•‡∏±‡∏Å‡∏Å‡∏≤‡∏£‡∏™‡∏∑‡πà‡∏≠‡∏™‡∏≤‡∏£‡∏Ç‡∏≠‡∏á Goroutines ‡∏ú‡πà‡∏≤‡∏ô Channels ‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô Channels ‡πÉ‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡∏ì‡πå‡∏ï‡πà‡∏≤‡∏á ‡πÜ

### üîå Channels ‡∏Ñ‡∏∑‡∏≠‡∏≠‡∏∞‡πÑ‡∏£?

Channel ‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô "‡∏ó‡πà‡∏≠‡∏ô‡πâ‡∏≥" ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á goroutines ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢

```
Goroutine A  ‚îÄ‚îÄ[data]‚îÄ‚îÄ‚ñ∫ Channel ‚îÄ‚îÄ[data]‚îÄ‚îÄ‚ñ∫ Goroutine B
        ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•              ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
```

### üéØ ‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏ó‡∏µ‡πà Channel ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç

**‡∏õ‡∏±‡∏ç‡∏´‡∏≤:** ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤ return ‡∏à‡∏≤‡∏Å goroutines ‡πÑ‡∏î‡πâ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á

```go
// ‚ùå ‡∏ó‡∏≥‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ!
result := go someFunction()
```

**‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•:** Go ‡πÑ‡∏°‡πà‡∏£‡∏π‡πâ‡∏ß‡πà‡∏≤ goroutine ‡∏à‡∏∞‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÄ‡∏™‡∏£‡πá‡∏à‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏´‡∏£‡πà

### üí° ‡∏ß‡∏¥‡∏ò‡∏µ‡πÅ‡∏Å‡πâ‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏î‡πâ‡∏ß‡∏¢ Channels

### ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ó‡∏µ‡πà 1: ‡∏Å‡∏≤‡∏£‡∏£‡∏ß‡∏°‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏à‡∏≤‡∏Å Multiple Goroutines

```go
package main

import (
  "fmt"
  "sync"
)

// ‚ú® ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á: ‡πÄ‡∏û‡∏¥‡πà‡∏° context ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö cancellation
func sum(numbers []int, ch chan<- int) { // ‡πÉ‡∏ä‡πâ send-only channel
  result := 0
  for _, num := range numbers {
    result += num
  }
  ch <- result // ‡∏™‡πà‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÄ‡∏Ç‡πâ‡∏≤ channel
}

func main() {
  numbers := make([]int, 30)
  for i := 0; i < 30; i++ {
    numbers[i] = i + 1 // [1, 2, 3, ..., 30]
  }

  // ‡∏™‡∏£‡πâ‡∏≤‡∏á buffered channel ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö 3 ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå
  ch := make(chan int, 3) // ‚ú® ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á: ‡πÉ‡∏ä‡πâ buffered channel

  // ‡πÅ‡∏ö‡πà‡∏á‡∏á‡∏≤‡∏ô‡πÄ‡∏õ‡πá‡∏ô 3 ‡∏™‡πà‡∏ß‡∏ô
  go sum(numbers[0:10], ch)   // 1-10
  go sum(numbers[10:20], ch)  // 11-20
  go sum(numbers[20:30], ch)  // 21-30

  // ‡∏£‡∏±‡∏ö‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå 3 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á
  totalResult := 0
  for i := 0; i < 3; i++ {
    result := <-ch // ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å channel
    totalResult += result
    fmt.Printf("Received result %d: %d\n", i+1, result)
  }

  fmt.Printf("Final result: %d\n", totalResult) // 465
  close(ch) // ‚ú® ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á: ‡∏õ‡∏¥‡∏î channel ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ‡πÄ‡∏™‡∏£‡πá‡∏à
}
```

### üìä ‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á Channel

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Goroutine 1 ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ Channel ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÇ Main Thread ‚îÇ
‚îÇ   sum(1-10) ‚îÇ    ‚îÇ   ch    ‚îÇ    ‚îÇ  ‡∏£‡∏≠‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    ‚ñ≤55               ‚îÇ               ‚ñ≤
    ‚îÇ                 ‚îÇ               ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îÇ        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Goroutine 2 ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ Goroutine 3 ‚îÇ
‚îÇ  sum(11-20) ‚îÇ        ‚îÇ        ‚îÇ  sum(21-30) ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    ‚ñ≤155             ‚îÇ               ‚ñ≤255
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚ñº
         totalResult = 465
```

### üîß ‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏à‡∏≤‡∏Å‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏î‡∏¥‡∏°

**‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á:**

1. **Buffered Channels:** ‡πÉ‡∏ä‡πâ `make(chan int, 3)` ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏•‡∏î blocking
2. **Directional Channels:** ‡πÉ‡∏ä‡πâ `chan<- int` (send-only) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢
3. **Proper Channel Closing:** ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å `close(ch)` ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ‡πÄ‡∏™‡∏£‡πá‡∏à
4. **Better Error Handling:** ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î

### üíé Patterns ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ Channels

#### 1. **Worker Pool Pattern**

```go
func workerPool() {
  jobs := make(chan int, 100)
  results := make(chan int, 100)

  // ‡∏™‡∏£‡πâ‡∏≤‡∏á 3 workers
  for w := 1; w <= 3; w++ {
    go worker(w, jobs, results)
  }

  // ‡∏™‡πà‡∏á‡∏á‡∏≤‡∏ô 5 ‡∏á‡∏≤‡∏ô
  for j := 1; j <= 5; j++ {
    jobs <- j
  }
  close(jobs)

  // ‡∏£‡∏±‡∏ö‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå 5 ‡∏ú‡∏•
  for a := 1; a <= 5; a++ {
    <-results
  }
}
```

#### 2. **Fan-out Fan-in Pattern**

```go
func fanOutFanIn() {
  input := make(chan int)

  // Fan-out: ‡πÅ‡∏à‡∏Å‡∏á‡∏≤‡∏ô‡πÉ‡∏´‡πâ workers
  c1 := worker(input)
  c2 := worker(input)

  // Fan-in: ‡∏£‡∏ß‡∏° results
  output := merge(c1, c2)

  // ‡πÉ‡∏ä‡πâ output channel
  for result := range output {
    fmt.Println(result)
  }
}
```

### üìà ‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û

| Sequential                 | Goroutines + Channels        |
| -------------------------- | ---------------------------- |
| ‚è±Ô∏è ‡πÄ‡∏ß‡∏•‡∏≤: O(n)              | ‚è±Ô∏è ‡πÄ‡∏ß‡∏•‡∏≤: O(n/workers)        |
| üîí Thread-safe ‡πÇ‡∏î‡∏¢‡∏ò‡∏£‡∏£‡∏°‡∏ä‡∏≤‡∏ï‡∏¥ | üîí Thread-safe ‡∏ú‡πà‡∏≤‡∏ô channels |
| üíæ Memory: ‡∏ô‡πâ‡∏≠‡∏¢            | üíæ Memory: ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏∂‡πâ‡∏ô‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢ |
| üß† ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ã‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô: ‡∏ï‡πà‡∏≥        | üß† ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ã‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô: ‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á      |

### ‚ö†Ô∏è Best Practices

1. **‡πÉ‡∏ä‡πâ Buffered Channels** ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏£‡∏π‡πâ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡πà‡∏ß‡∏á‡∏´‡∏ô‡πâ‡∏≤
2. **‡∏õ‡∏¥‡∏î Channels** ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ‡πÅ‡∏•‡πâ‡∏ß
3. **‡πÉ‡∏ä‡πâ Select Statement** ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö non-blocking operations
4. **‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á Channel ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô** ‡∏≠‡∏¢‡πà‡∏≤‡πÉ‡∏ä‡πâ‡πÄ‡∏Å‡∏¥‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£

### üéØ ‡∏™‡∏£‡∏∏‡∏õ

Channels ‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡πÉ‡∏ô Go ‡∏ó‡∏µ‡πà‡∏ä‡πà‡∏ß‡∏¢‡πÉ‡∏´‡πâ goroutines ‡∏™‡∏∑‡πà‡∏≠‡∏™‡∏≤‡∏£‡∏Å‡∏±‡∏ô‡πÑ‡∏î‡πâ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢ ‡∏ï‡∏≤‡∏°‡∏´‡∏•‡∏±‡∏Å‡∏Å‡∏≤‡∏£:

> **"Don't communicate by sharing memory; share memory by communicating"**

‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ channels ‡∏£‡πà‡∏ß‡∏°‡∏Å‡∏±‡∏ö goroutines ‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡πÄ‡∏£‡∏≤‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏° concurrent ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û‡πÅ‡∏•‡∏∞‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢‡πÑ‡∏î‡πâ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏á‡πà‡∏≤‡∏¢‡∏î‡∏≤‡∏¢
